<p align="center"><b>МОНУ НТУУ КПІ ім. Ігоря Сікорського ФПМ СПіСКС</b></p>
<p align="center">
<b>Звіт з лабораторної роботи 4</b><br/>
"Функції вищого порядку та замикання"<br/>
дисципліни "Вступ до функціонального програмування"
</p>
<p align="right"><b>Студент(-ка)</b>: Прізвище Ім'я По-батькові Група</p>
<p align="right"><b>Рік</b>: 2025</p>

## Загальне завдання

1.  **Рефакторинг алгоритму сортування:** Переписати функціональну реалізацію алгоритму сортування з попередньої лабораторної роботи, використовуючи функції вищого порядку (HOF) для роботи з послідовностями. Додати підтримку ключових параметрів `key` та `test`, забезпечивши мінімальну кількість викликів функції `key` (кешування значення ключа).
2.  **Робота із замиканнями:** Реалізувати функцію, що створює замикання, яке працює згідно із завданням за варіантом (обробка списків за допомогою `mapcar` зі збереженням стану між ітераціями).

## Варіант першої частини
**Алгоритм сортування вибором (Selection Sort).**

## Лістинг реалізації першої частини завдання
```lisp
(defun extract-min (lst key test)
  "Знаходить мінімальний елемент і повертає:
   1. Саме значення мінімального елемента.
   2. Список без першого входження цього елемента."
  (if (null lst)
      (values nil nil)
      ;; Використовуємо reduce для пошуку мінімуму за один прохід
      ;; Акумулятор зберігає пару (best-element . best-key)
      (let* ((min-pair (reduce (lambda (best current)
                                 (let ((best-val (car best))
                                       (best-key (cdr best))
                                       (curr-key (funcall key current)))
                                   ;; Порівнюємо ключі, використовуючи test
                                   (if (funcall test curr-key best-key)
                                       (cons current curr-key) ;; Новий мінімум
                                       best)))                 ;; Залишаємо поточний
                               (rest lst)
                               ;; Початкове значення: перший елемент та його ключ
                               :initial-value (cons (first lst) (funcall key (first lst)))))
             (min-val (car min-pair)))
        
        ;; Повертаємо два значення: знайдений елемент та список без нього
        ;; :count 1 гарантує видалення лише однієї копії
        (values min-val (remove min-val lst :count 1)))))

(defun selection-sort-func (lst &key (key #'identity) (test #'<))
  "Рекурсивна функція сортування вибором з використанням HOF."
  (cond
    ((null lst) nil)
    (t 
     ;; Використовуємо multiple-value-bind для отримання результатів extract-min
     (multiple-value-bind (min-val rest-lst) (extract-min lst key test)
       (cons min-val 
             (selection-sort-func rest-lst :key key :test test))))))
